#!/usr/bin/env bash
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# Options
#     -p
#         if passed, runs the case in parallel
#
# Optional environment variables
#     Mesh density level
:     "${MESH_LEVEL:=1}"
#     Number of mesh subdomains (only used in parallel run)
:     "${NUMBER_OF_SUBDOMAINS:=4}"
#     Fluid model to be called by solids4Foam (pimpleFluid, newtonIcoFluid)
:     "${FLUID_MODEL:=pimpleFluid}"
#     Mesh type:
#         TET           unstructured tetrahedral mesh
#         POLY          unstructured polyhedral mesh
:     "${MESH:=POLY}"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
cd "${0%/*}" || exit    # Run from this directory
set -e

# Source tutorial run functions
. "${WM_PROJECT_DIR}"/bin/tools/RunFunctions

case "${MESH}" in
    "TRI" | "POLY")
        if ! command -v gmsh &> /dev/null
        then
            echo "gmsh not found: please install it" >&2
            exit 1
        fi

        echo "Generating ${MESH} mesh using Gmsh."

        # Generate the mesh using Gmsh
        runApplication gmsh -3 -format msh2 -setnumber meshLevel "${MESH_LEVEL}" \
            gmsh/oscillatingSphereInCube.geo \
            -o gmsh/oscillatingSphereInCube.msh

        # Convert Gmsh mesh to OpenFOAM format
        runApplication gmshToFoam gmsh/oscillatingSphereInCube.msh

        if [[ "${MESH}" == "POLY" ]]
        then
            mv 0 0.tmp

            # Convert to polyhedral mesh
            runApplication polyDualMesh 45 -overwrite

            # Combine faces into larger polygons so that the angle between edges
            # is less than 45 degrees.
            runApplication combinePatchFaces 45 -overwrite

            mv 0.tmp 0
        fi

        ;;

    *)
        echo "Invalid mesh type: '${MESH}'." >&2
        echo "Choose one of QUAD, QUAD_GRADED, TRI or POLY." >&2
        exit 1
        ;;
esac

if [ "$1" = '-p' ];
then
    # Decopose mesh
    NUMBER_OF_SUBDOMAINS="${NUMBER_OF_SUBDOMAINS}" runApplication decomposePar

    # Run the solver (parallel)
    FLUID_MODEL="${FLUID_MODEL}" runParallel "$(getApplication)"

    # Deconstruct the result
    runApplication reconstructPar -no-fields -latestTime
else
    # Run the solver (serial)
    FLUID_MODEL="${FLUID_MODEL}" runApplication "$(getApplication)"
fi

# Generate the plots - to-do
#cp ../plotScripts/*.gnuplot .
#cp ../validationData/*.dat .

for script in ./*.gnuplot
do
    gnuplot -c "${script}"
done
